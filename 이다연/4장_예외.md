## 1. 초난감 예외처리

### 1. 예외 블랙홀

- 예외를 try-catch로 잡고 아무것도 하지 않아 오류를 찾기 어렵다는 문제가 있음
- 모든 예외는 적절하게 복구되던가 아니면 작업을 중단시키고 운영자 또는 개발자에게 분명하게 통보돼야 함
- 무책임한 throws 선언도 심각한 문제점이 있음

### 2. 예외의 종류와 특징

- 체크예외: 명시적인 처리가 필요한 예외를 사용하고 다루는 방법

**에러의 종류**

- Error
    - java.lang.Error의 서브클래스
    - 자바 VM에서 발생하므로 애플리케이션 코드에서 못 잡음
- Exception과 체크 예외
    - java.lang.Error 클래스와 그 서브클래스로 정의되는 예외
    - 애플리케이션 코드의 작업 중 예외 상황이 발생했을 경우에 사용
    - 체크예외
        - Exception class의 sub class이면서 RuntimeException class를 상속하지 않은 것 → 일반적인 예외
        - IOException, SQLException등 예외적인 상황에서 던져질 가능성이 있는 것 → 체크예외
    - 언체크 예외
        - RuntimeException class를 상속한 클래스
    - RuntimeException과 언체크/런타임 예외
        - java.lang.RuntimeException 클래스를 상속한 예외
        - 명시적인 예외처리를 강제하지 않음 → 언체크,런타임 예외라고 불림
        - 프로그램의 오류가 있을 때 발생하도록 의도됨
    - 자바 표준 스펙의 API들은 예상 가능한 예외상황을 다루는 예외를 체크 예외로 만들지 않는 경향이 있음

### 3. 예외처리 방법

**예외 복구**

- 예외상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것
- 예외가 처리됐으면 기능적으로 사용자에게 예외상황으로 비쳐도 애플리케이션에서는 정상적으로 설계된 흐름을 따라 진행돼야 함
- 예외처리 코드들을 강제하는 체크 예외들은 예외를 어떤 식으로든 복구할 가능성이 있는 경우에 사용함
    - ex) 사전에 미리 성공 여부를 확인할 수 없고, 재시도가 의미 있는 경우 → 최대 횟수만큼 반복적으로 시도해서 예외상황에서 복구되게 함

**예외처리 회피**

- 예외처리를 자신이 담당하지 않고 자신을 호출한 쪽으로 던져버리는 것
- throws문으로 선언 → 예외 발생 → 알아서 던져지거나 catch문으로 예외를 잡은 후 로그를 남기고 다시 예외를 던짐(rethrow)
- 예외처리를 회피하려면 반드시 다른 오브젝트나 메소드가 예외를 대신 처리할 수 있도록 던져줘야 함
    
    ```java
    public void add() throws SQLException {
    	try {
    	//jdbc api
    		}
    	catch {
    		//log출력
    		throw e;
    		}
    	}
    ```
    
- 콜백 메소드의 오브젝트는 SQLException에 대한 예외를 회피하고 템플릿 레벨에서 처리하도록 던져줌
- 예외를 회피하는것은 의도가 분명해야 함 → 콜백/템플릿처럼 긴밀한 관계에 있는 다른 오브젝트에게 예외처리 책임을 분명히 지게 하거나, 자신을 사용하는 쪽에서 예외를 다루는 게 최선의 방법이어야 함

**예외 전환**

- 적절한 예외로 전환해서 예외를 메소드 밖으로 던지는 것
- 예외 상황에 대한 의미를 분명하게 해줄 수 있음 → 서비스 계층 오브젝트에서 적절한 복구 작업을 시도할 수 있음
- 전환 방법
    - 전환하는 에러에 원래 발생한 예외를 담아서 중첩예외로 만드는 것이 좋음
        - 새로운 예외를 만들면서 생성자나 initCause()메소드로 근본 원인이 되는 예외를 넣어주면 됨
    - 포장
        - 중첩 예외를 이용해 새로운 예외를 만들고 원인이 되는 예외를 내부에 담아서 던지는 방식
        - 예외처리를 강제하는 체크 예외를 언체크 예외인 런타임 예외로 바꾸는 경우에 사용 → 의미를 명확하게 하려고 다른 예외로 전환하는 것이 아님
        - RuntimeException을 상속한 EJBException
            - exception발생 시 EJB는 system exception으로 인식하고 트랜잭션을 자동으로 콜백
        - 애플리케이션 로직에서 예외조건/상황 발생한다면? → 애플리케이션 코드에서 의도적으로 던져지는 예외이므로 체크 예외를 사용하는 것이 적절함 → 비즈니스적인 의미가 있는 예외는 이에 대한 적절한 대응, 복구작업이 필요하기 때문
        - 복구가 불가능한 예외라면 RuntimeException으로 포장해 던지게 해서 다른 계층의 메소드를 작성할 때 불필요한 throws선언이 들어가지 않도록 해줘야 함
- 복구하지 못할 예외라면 애플리케이션 코드에서는 런타임 예외로 포장해서 던져버리고, 예외처리 서비스 등을 이용해 로그를 남기는 것이 바람직함

### 4. 예외처리 전략

**런타임 예외의 보편화**

- 체크 예외는 복구할 가능성이 있는 일반적인 예외 → catch 블록이나 throws선언을 강제함
- 자바 엔터프라이즈 서버환경은 각 요청이 독립적인 작업으로 취급됨 → 하나의 요청을 처리하는 중에 예외가 발생하면 해당 작업만 중단됨 → 예외 발생 시 바로 예외 상황을 복구할 수 x
    - 이 환경에서는 애플리케이션 차원에서 예외상황을 미리 파악하고, 예외가 발생하지 않도록 차단하는 것이 중요함
    - 대응이 불가능한 체크 예외라면 RuntimeException으로 전환해서 던지는게 나음
- 항상 복구할 수 있는 예외가 아니라면 → 언체크 예외로 만들기

**add()메소드의 예외처리**

- 복구가 불가능한 SQLException → RuntimeException으로 포장해 던져버려서 그 밖의 메소드들이 신경 쓰지 않게 해주는 편이 나음
- 어느 계층에서든 해당 Exception을 처리할 수 있다면 굳이 체크 예외로 만들지 않고 RuntimeException으로 만드는 게 나음

```java
//예외 선언
public class DuplicateUserIdException extends RuntimeException {
		public DuplicateUserIdException(Throwable cause) {
				super(cause);
		}
}

//add()메소드에서 예외가 발생한다면?
public void add() throws DuplicateUserIdException {
		try {
		
		}
		catch(SQLException e) {
				if(e.getErrorCode() == MysqlErrorNumbers.ER_DUP_ENTRY)
						throw new DuplicateUserIdException(e); //예외 전환
				else
					throw new RuntimeException(e); //예외 포장
		
```

- SQLException을 RuntimeException으로 전환해서 던짐
- 문제점 → 컴파일러가 예외처리를 강제하지 않으므로 예외 상황을 충분히 고려하지 않을 수 있음
- 문서로 예외의 종류, 원인, 활용 방법을 자세히 설명해 둬야 함

**애플리케이션 예외**

- 애플리케이션 자체의 로직에 의해 의도적으로 발생시키고 catch 해서 조치를 취하도록 하는 예외
- 방법
    1. 리턴 값으로 결과를 확인하고, 예외상황 체크하는 방법
        - 예외상황에 대한 리턴 값을 명확하게 코드화하고 관리하지 않으면 혼란이 생길 수 있음
        - 결과 값을 확인하는 조건문이 자주 등장함 → 코드가 난잡해짐
    2. 예외 상황에서 비즈니스적인 의미를 띈 예외를 던지는 방법
        - 예외가 발생할 수 있는 코드 → try 블록에
        - 예외 상황에 대한 처리 → catch 블록에
        - 이때는 의도적으로 체크 예외로 만듬 → 예외상황에 대한 로직을 구현하도록 강제해줘야 함
        
        //내 커스텀 익셉션과의 관계..? 특히 체크 예외
        
    
    ```java
    try {
    //정상적인 처리에 대한 출력 결과
    }
    catch(InsufficientBalanceException e) {
    	//예외 상황에 대한 로직 구현(메시지 출력 등)
    }
    ```
    

### 5. SQLException은 어떻게 됐나?

- DAO에 존재하는 SQLException → 코드 레벨에서는 복구할 방법이 없음 → 시스템의 예외이기 때문
- 관리자나 개발자가 빨리 인식할 수 있도록 발생한 예외를 전달해야 함
- 예외처리 전략을 적용해서 언체크/런타임 예외로 전환해줘야 함 → JdbcTemplate는 이 예외처리 전략을 따르고 있음
    - JdbcTemplate과 콜백에서 발생하는 모든 SQLException → RuntimeException인 DataAccessException으로 포장해서 던져줌 → JdbcTemplate를 사용하는 UserDao메소드에선 꼭 필요한 경우에만 DataAccessException을 처리하면 됨
- 그 외에도 스프링의 API메소드에 정의되어 있는 대부분의 예외 → 런타임 예외

## 2. 예외 전환

**예외 전환의 목적**

- 런타임 예외로 포장해서 필요하지 않은 catch/throws 줄여줌
- 로우레벨의 예외를 좀 더 의미있고 추상화된 예외로 바꿔서 던져줌

### 1. JDBC의 한계

- JDBC는 DB를 자유롭게 변경해서 사용할 수 있는 유연한 코드를 보장해주지 못함

**비표준 SQL**

- 비표준 SQL: 특별한 기능을 제공하는 함수를 sql에 사용한 것
- 비표준 SQL은 DAO에 들어가고, 해당 DAO는 특정DB 종속적인 코드가 됨
- 이 문제를 해결하려면 DAO를 DB별로 만들어 사용하거나 SQL을 외부에서 독립시켜서 바꿔 쓸 수 있게 해야 함

**호환성 없는 SQLException의 DB 에러정보**

- JDBC는 데이터 처리 중에 발생하는 다양한 예외를 SQLException 하나에 모두 담음 → 예외가 발생한 원인은 에러코드와 SQL 상태정보를 참조해봐야 함 → DB마다 다름
- SQLException만으로 DB에 독립적인 유연한 코드를 작성하는건 불가능함

### 2. DB 에러 코드 매핑을 통한 전환

- DB별 에러 코드를 참고해서 발생한 예외의 원인이 무엇인지 해석해 주는 기능을 만들기
- 문제는 DB마다 에러 코드가 제각각임 → 스프링에서는 이를 에러 코드 매핑정보 테이블을 이용해서 해결할 수 있음
- JdbcTemplate는 SQLException을 DataAccessException으로 포장하는 것이 아니라 DB의 에러 코드를 DataAccessException계층구조의 클래스 중 하나로 매핑해 줌 → 드라이버나 DB메타정보를 참고해서 DB종류를 확인하고 매핑정보를 참고해서 Exception class를 선택함
- 즉, JdbcTemplate안에서 DB별로 미리 준비된 에러 코드와 비교해서 적절한 예외를 던져줌
- 만약 custom exception을 사용하고 싶다면 스프링의 예외를 전환해주는 코드를 DAO에 넣으면 됨
- 하지만 SQLException의 서브클래스이므로 여전히 체크 예외고, 그 예외를 세분화하는 기준이 SQL상태정보를 이용한다는 점에서 여전히 문제점이 있음

### 3. DAO 인터페이스와 DataAccessException계층구조

- 하이버네이트 → ORM 기술
- DataAccessException → 의미가 같은 예외라면 데이터 액세스 기술의 종류와 상관없이 일관된 예외가 발생하도록 만들어 줌 → 데이터 액세스 기술에 독립적인 추상화된 예외를 제공함

**DAO 인터페이스와 구현의 분리**

- DAO를 만든 이유 → 데이터 액세스 로직을 담은 코드를 성격이 다른 코드에서 분리해놓고, 전략 패턴을 적용해 구현 방법을 변경해서 사용할 수 있게 만들 수 있음
- DAO를 사용하는 쪽에서는 DAO내부의 data access기술에 대해 신경쓰지 않아도 됨 → DAO는 인터페이스를 사용해 구체적인 클래스 정보와 구현 방법을 감추고, DI를 통해 제공되도록 만드는게 바람직함
- 하지만 메소드 선언에 나타나는 예외정보가 문제가 됨 → interface의 메소드 선언에는 없는 예외를 구현 클래스 메소드의 throws에 넣을 수 없음
- 인터페이스로 DAO method의 구현은 추상화했지만, 구현 기술마다 던지는 예외가 다르기 때문에 메소드의 선언이 달라지는 문제 발생함
- 가장 단순한 해결 방법 → throws Exception으로 예외 처리
- JDO, Hibernate, JPA는 SQLException같은 체크 예외 대신 런타임 예외 사용함 → throws에 연결을 안해줘도 됨
- 대부분의 DAO예외는  애플리케이션에서는 복구 불가능하거나 할 필요가 없는 것임 → 데이터 액세스 기술이 달라지면 클라이언트는 DAO의 사용 기술에 따라 예외 처리 방법이 달라져야 함 → 클라이언트가 DAO의 기술에 의존적이게 됨

**데이터 액세스 예외 추상화와 DataAcessException 계층구조**

- 클라이언트가 DAO의 기술에 의존적이게 됨 → 그래서 스프링은 데이터 액세스 기술을 사용할 때 발생하는 예외들을 추상화해서 DataAccessException계층구조 안에 정리해 놓음

**낙관적인 락킹**

- 같은 정보를 두 명 이상의 사용자가 동시에 조회하고 순차적으로 업데이트를 할 때, 뒤늦게 업데이트한 것이 먼저 업데이트한 것을 덮어쓰지 않도록 막아주는 데 쓸 수 있는 기능
- DataAccessException의 서브클래스인 ObjectOpimisticLockingFailureException으로 통일시킬 수 있음 → 이를 이용해 낙관적인 락킹을 처리하는 코드를 만들 수 있음
- DataAccessException계층구조에는 템플릿 메소드나 DAO 메소드에서 직접 활용할 수 있는 예외도 정의되어 있음
- JdbcTemplate와 같이 스프링의 데이터 액세스 지원 기술을 이용해 DAO를 만들면 사용 기술에 독립적ㅇ니 일관성 있는 예외를 던질 수 있음
- 인터페이스 사용, 런타임 예외 전환, DataAccessException 예외 추상화 적용 → 데이터 액세스 기술과 구현 방법에 독립적인 이상적인 DAO를 만들 수 있음