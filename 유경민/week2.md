오늘의 주제는 TEST이다.
스프링에서의 테스트란 무엇일까?
알아보자.

### 단위 테스트
단위 테스트(_Unit Test_)는 한 단위의 기준은 없다. 
크게는 사용자 관리 기능을 통틀어서 테스트를 진행할 수도 있고
작게는 사용자 관리 기능의 add()메서드 하나를 테스트할 수도 있는 것이다.<sup>[1](#unitTest)</sup>
 
어찌 되었든, 단위 테스트의 의의는 관심사의 분리에 있다. 관심 대상은 명확히 해서 해당 기능의 에러 가능성만 살피는 것이다. 




#### 테스트의 조건
빠른 코드의 확인과 확실성을 위해서 두 가지 조건을 만족하는 테스트 코드가 되어야 한다.

1. 자동 수행
예를 들어, 단순 콘솔에 출력하는 System.out.println()을 사용하면 이것이 개발자의 의도와 맞는지는 개발자가 하나하나 확인해야 하는 것이다. 검증해야 할 양이 많아지면 못 보고 넘어가는 실수도 생길 것이다.

2. 테스트의 효율성
단순 main() 메소드로는 한계가 있다. 테스트의 결과를 종합해서 보며 실패 지점을 빠르게 찾을 수 있는 기능을 갖춘 방식이 필요하다.
그래서... 스프링은...
</br>

### JUnit
사실상 자바의 표준 테스팅 프레임워크이다. 대부분의 자바 IDE는 JUnit 테스트 지원 기능을 내장한다. 
대표적인 기능으로 assertThat, assertTrue 등이 있고 자세한 기능은 다음 링크를 참조한다.
[Assertions](https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/Assertions.html#method-summary)


테스트는 개발자가 실패가 되지 않게끔 코드를 짜는 경향이 있을 수 있는데 그것을 피하고 아주아주 최악의 케이스를 넣어 테스트 코드를 진행해야 옳다. 


### TDD
테스트 주도 개발(TDD, Test-Driven Development)은 소프트웨어 개발 방법론 중 하나로, 코드를 작성하기 전에 테스트를 먼저 작성하는 방식이다. 이 방법론은 개발자가 코드의 기능을 명확히 정의하고, 더 나은 품질의 소프트웨어를 작성할 수 있도록 돕는다. TDD는 일반적으로 다음 세 가지 단계를 반복하는 사이클로 이루어진다.

**테스트 작성 (Red 단계):**

작성하려는 기능에 대한 테스트 코드를 먼저 작성한다.
이 테스트는 코드가 아직 존재하지 않거나 완성되지 않았기 때문에 실패하는 것이 정상이다.

**코드 작성 (Green 단계):**

테스트가 통과할 수 있도록 최소한의 코드를 작성한다.
이 단계에서는 기능을 구현하는 데 집중하며, 테스트를 통과시키는 것을 목표로 한다.

**리팩토링 (Refactor 단계):**

작성한 코드와 테스트 코드를 개선한다.
코드의 중복을 제거하거나 가독성을 높이는 등의 작업을 수행한다.
리팩토링 후에도 테스트는 여전히 통과해야 한다.
이 과정을 반복하면서 점진적으로 기능을 추가하고 소프트웨어를 발전시켜 나간다.

#### TDD의 장점
버그 감소: 테스트가 코드 작성 전에 설계되므로, 코드에 숨겨진 버그를 일찍 발견할 수 있다.
코드 품질 향상: 리팩토링을 통해 코드의 품질을 지속적으로 개선할 수 있다.
문서화 역할: 테스트 코드 자체가 코드의 기능에 대한 설명과 예시가 되므로, 문서화 역할을 한다.
변화에 대한 자신감: 코드 변경 시, 기존 테스트를 통해 새로 추가한 코드나 수정한 코드가 의도한 대로 동작하는지 확인할 수 있다.
#### TDD의 단점
시간 소모: 초기 개발 시 테스트 코드를 작성하는 데 시간이 더 걸릴 수 있다.
테스트 유지 관리: 코드가 변경될 때마다 테스트 코드도 함께 수정해야 하는 부담이 따른다.
적응 어려움: TDD에 익숙하지 않은 개발자나 팀이 처음 적용할 때는 익숙해지기까지 시간이 필요할 수 있다.
TDD는 코드의 안정성과 품질을 높이기 위한 강력한 도구이지만, 상황에 따라 적용 방법이 달라질 수 있다.



### DI와 테스트의 관계

**단위 테스트의 용이성:**

DI를 사용하면 객체가 사용하는 의존성을 외부에서 주입받기 때문에, 테스트 환경에서 실제 객체 대신 목(Mock) 객체나 스텁(Stub)을 쉽게 주입할 수 있다.
이를 통해 테스트하려는 대상 코드와 의존성 간의 상호작용을 독립적으로 제어하고, 테스트 결과를 예측하기 쉽게 만든다.

**의존성 관리의 편리함:**

의존성을 외부에서 관리하고 주입하므로, 코드 내에서 의존성을 변경하거나 업데이트할 때 발생할 수 있는 영향을 최소화할 수 있다.
이로 인해 테스트 코드가 의존성의 변화에 덜 민감하게 되며, 유지 보수성이 높아진다.

**결합도 감소:**

DI를 통해 객체 간의 결합도를 낮추면 코드의 모듈성이 높아지고, 각각의 모듈을 독립적으로 테스트할 수 있는 환경이 조성된다.
결합도가 낮은 시스템은 특정 모듈의 변경이 다른 모듈에 미치는 영향을 줄여, 테스트의 안정성과 예측 가능성을 높인다.

**자동화 테스트의 유리함:**

DI는 다양한 구성이나 상태에 대해 객체를 초기화하는 데 유리하기 때문에, 자동화된 테스트에서 여러 가지 상황을 쉽게 재현할 수 있다.
이는 테스트 커버리지를 높이고, 예외 상황이나 에러 처리 로직을 더 철저하게 검증할 수 있게 한다.

### DI와 TDD(Test-Driven Development)

설계의 유연성: TDD에서는 테스트를 먼저 작성한 후에 실제 코드를 작성하게 되는데, DI를 사용하면 테스트가 요구하는 형태로 객체를 설계하기가 수월하다. 이를 통해 코드를 리팩토링할 때도 기존 테스트가 쉽게 통과될 수 있도록 도와준다.
빠른 피드백 루프: DI를 통해 의존성을 손쉽게 교체하고 테스트할 수 있기 때문에, TDD의 빠른 피드백 루프를 유지하는 데 큰 도움이 된다.
DI의 구현 방법

1. 생성자 주입 (Constructor Injection): 객체의 생성자에서 필요한 의존성을 전달받는 방식이다. 가장 일반적이고 권장되는 방식으로, 객체가 생성될 때 모든 의존성이 주입되어야 함을 명확히 한다.

 2. 세터 주입 (Setter Injection): 객체 생성 후, 세터 메서드를 통해 의존성을 주입하는 방식이다. 선택적 의존성이나 변경 가능한 의존성에 사용될 수 있지만, 테스트 과정에서 의존성이 누락될 가능성이 있어 주의가 필요하다.

3. 인터페이스 주입 (Interface Injection): 의존성을 주입받기 위한 메서드를 인터페이스로 정의하고, 이를 구현하는 객체가 의존성을 주입받는 방식이다. 상대적으로 잘 사용되지 않지만, 특정 프레임워크에서 유용하게 쓰일 수 있다.

---
<a name="unitTest">1</a> 그러나 일반적으로 단위가 적을수록 좋다
